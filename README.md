This really needs examples and something like a blog post to explain (but you can take a look at the tests and inspect the type of e.g. `f.props` in your editor).  But:

This is an experiment to see how it turns out to use TypeScript type inference and ["correlated unions"](https://github.com/Microsoft/TypeScript/issues/30581) to propagate types from fixture factory functions (`Factory`) to the types of fixtures constructed by a "fixture memo" factory class (`FixtureMemo`).  That class uses the test fixture construction pattern used in https://github.com/jjlee/fixt (which is essentially the same pattern as used in py.test, with some caveats).

The idea is: Is it feasible to avoid having to write out fixture types, even if typescript infers them from the fixture function?  Without this type hack, you have to have the types once in the functions that make the fixtures (perhaps inferred), and then again, written out explicitly in an interface for the factory class.  You have to do that every time you use the class (because the fixture types you're using will be different depending on the code you're testing), and so every time you add or change a fixture type.  This isn't a terrible burden, but I wondered if I could avoid it.

Though I think it was a worthwhile experiment to see how far I could push this, I don't recommend actually using anything like this in real code.  For one thing, it's a bit crazy.  Also, the factory class ends up with a type that involves complicated intersection types (one intersection per fixture factory function).  I don't think there's currently a way to avoid that.  I also wonder what the performance implications are for `tsc` runs.  In a real application, I think it's better to explicitly declare your fixture types (that also works in Python with mypy).
